package main

import (
	"context"
	"encoding/binary"
	"flag"
	"log"
	"os"
	"path/filepath"
	"strconv"
	"sync"

	"github.com/apache/beam/sdks/go/pkg/beam"
	"github.com/apache/beam/sdks/go/pkg/beam/x/beamx"
)

var (
	ctx = context.Background()
)

const (
	wordSz = 6
	gWidth = 1 << 24
)

type Edge struct {
	src, dst int
}

type FileInfo struct {
	path  string
	bsize int64
}

type ListInfo struct {
	src   int
	pos   int
	bsize int
}

type Listb struct {
	src int
	dst []byte
}

type List struct {
	src int
	dst []int
}

func BE6toLE8(in []byte) int {
	return (int(in[0]) << (8 * 5)) +
		(int(in[1]) << (8 * 4)) +
		(int(in[2]) << (8 * 3)) +
		(int(in[3]) << (8 * 2)) +
		(int(in[4]) << (8 * 1)) +
		(int(in[5]) << (8 * 0))
}

func init() {
	inFolder := flag.String("in.folder", "", "Folder path for input files")
	outFolder := flag.String("out.folder", "", "Folder path for input files")
	outName := flag.String("out.name", "", "Folder path for input files")
	flag.Parse()

	if len(os.Args) == 0 || *inFolder == "" {
		flag.Usage()
		os.Exit(1)
	}

	ctx = context.WithValue(ctx, "inFolder", *inFolder)
	ctx = context.WithValue(ctx, "outFolder", *outFolder)
	ctx = context.WithValue(ctx, "outName", *outName)

	beam.Init()
}

func walkFile(inFolder string) []FileInfo {
	paths := []FileInfo{}
	filepath.Walk(inFolder, func(path string, info os.FileInfo, err error) error {
		file, err := os.Open(path)
		if err != nil {
			return nil
		}

		defer file.Close()

		if info.IsDir() || info.Size() == 0 {
			return nil
		}

		absPath, _ := filepath.Abs(path)
		paths = append(paths, FileInfo{
			path:  absPath,
			bsize: info.Size(),
		})

		return nil
	})

	return paths
}

func loader(inFile FileInfo) []byte {
	file, _ := os.Open(inFile.path)
	defer file.Close()

	out := make([]byte, inFile.bsize)
	file.Read(out)
	log.Println("load Done")
	return out
}

func splitter(in []byte) []Listb {
	out := []Listb{}

	for i := 0; i < len(in); {
		//for int64(pos) < inFile.bsize {
		src := BE6toLE8(in[i : i+wordSz])
		i += wordSz

		cnt := BE6toLE8(in[i : i+wordSz])
		i += wordSz

		out = append(out, Listb{
			src: src,
			dst: in[i : i+(wordSz*cnt)],
		})
		i += wordSz * cnt
	}

	log.Println("Split Done")

	return out
}

func convertFileToAdj(info Listb) List {
	log.Println("convertFileToAdj Start")
	dst := make([]int, len(info.dst)/wordSz)

	for i := 0; i < len(info.dst); {
		dst[i/wordSz] = BE6toLE8(info.dst[i : i+wordSz])
		i += wordSz
	}

	return List{
		src: info.src,
		dst: dst,
	}
}

func convertAdjToEdgelist(list List) []Edge {
	el := make([]Edge, len(list.dst))
	for i, d := range list.dst {
		s := list.src
		if s < d {
			s, d = d, s //swap
		}
		el[i] = Edge{
			src: s,
			dst: d,
		}
	}

	return el
}

func mapper(value Edge) (string, Edge) {
	return strconv.FormatInt(int64(value.src/gWidth), 10) + "-" + strconv.FormatInt(int64(value.dst/gWidth), 10),
		Edge{value.src % gWidth, value.dst % gWidth}
}

func reducer(key string, values func(*Edge) bool) (string, []Edge) {
	var e Edge
	el := []Edge{}
	for values(&e) {
		el = append(el, e)
	}

	return key, el
}

type Edgelist []Edge

func (el Edgelist) Len() int {
	return len(el)
}

func (el Edgelist) Swap(i, j int) {
	el[i], el[j] = el[j], el[i]
}

func (el Edgelist) Less(i, j int) bool {
	return (el[i].src < el[j].src) || (el[i].src == el[j].src && el[i].dst < el[j].dst)
}

func writer(key string, el []Edge) {
	outFolder := ctxString(ctx, "outFolder") + "/" + ctxString(ctx, "outName") + "/"

	if _, err := os.Stat(outFolder); os.IsNotExist(err) {
		os.MkdirAll(outFolder, 0755)
	}

	outFile := outFolder + key + ".el"
	file, err := os.OpenFile(outFile, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		log.Panicln(err)
	}
	defer file.Close()

	//sort.Sort(Edgelist(el))

	barrSz := len(el) * 4 * 2
	barr := make([]byte, barrSz)

	for i, e := range el {
		tmpSrc := make([]byte, binary.MaxVarintLen32)
		tmpDst := make([]byte, binary.MaxVarintLen32)
		binary.LittleEndian.PutUint32(tmpSrc, uint32(e.src))
		binary.LittleEndian.PutUint32(tmpDst, uint32(e.dst))
		for j := 0; j < 4; j++ {
			barr[4*2*i+j] = tmpSrc[j]
		}

		for j := 0; j < 4; j++ {
			barr[4*2*i+4+j] = tmpDst[j]
		}
	}

	if _, err := file.Write(barr); err != nil {
		log.Panicln(err)
	}
}
func main() {
	phase1 := func(finfo FileInfo) {
		input := loader(finfo)

		p, s := beam.NewPipelineWithRoot()
		// pc stands for pcollection
		pcSplitted := beam.Explode(s, beam.ParDo(s, splitter, beam.Create(s, input)))
		pcAdj := beam.ParDo(s, convertFileToAdj, pcSplitted)
		pcEdge := beam.Explode(s, beam.ParDo(s, convertAdjToEdgelist, pcAdj))
		pcEdgeKeyGrid := beam.ParDo(s, mapper, pcEdge)
		pcEdgeGrouped := beam.ParDo(s, reducer, beam.GroupByKey(s, pcEdgeKeyGrid))
		beam.ParDo0(s, writer, pcEdgeGrouped)

		if e := beamx.Run(ctx, p); e != nil {
			panic(e)
		}
	}

	// Boss
	jobs := func() <-chan FileInfo {
		out := make(chan FileInfo, 16)
		go func() {
			defer close(out)
			for _, f := range walkFile(ctxString(ctx, "inFolder")) {
				out <- f
			}
		}()
		return out
	}()

	// Worker
	var wg sync.WaitGroup
	for worker := 0; worker < 1; worker++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for f := range jobs {
				phase1(f)
			}
		}()
	}

	wg.Wait()
}
